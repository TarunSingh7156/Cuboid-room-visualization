{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "a8ea0bb5-6ebc-4d01-b766-608b245ac572",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Best solution: L=44, W=46, H=38 (grid units), Bricks=9896\n"
     ]
    }
   ],
   "source": [
    "import csv\n",
    "\n",
    "# Brick and wall parameters (mm)\n",
    "BRICK_L = 200  # mm\n",
    "BRICK_W = 100\n",
    "BRICK_H = 100\n",
    "WALL_THICKNESS = 200  # mm\n",
    "\n",
    "MAX_BRICKS = 10000\n",
    "\n",
    "# Convert mm to grid units (100 mm base)\n",
    "UNIT = 100\n",
    "t = WALL_THICKNESS // UNIT  \n",
    "brick_len = BRICK_L // UNIT  \n",
    "brick_w = BRICK_W // UNIT    \n",
    "brick_h = BRICK_H // UNIT    \n",
    "\n",
    "\n",
    "def brick_count(L, W, H):\n",
    "    \"\"\"Compute total bricks for given outer grid size (100 mm units).\"\"\"\n",
    "    shell_cells = L * W * H - (L - 2 * t) * (W - 2 * t) * (H - 2 * t)\n",
    "    return shell_cells // (brick_len)  # each brick occupies 2 grid cells (200mm)\n",
    "\n",
    "\n",
    "# Step 1. Find max interior volume with <=10,000 bricks\n",
    "best = None\n",
    "for L in range(20, 120, 2):  # 2*100 mm steps\n",
    "    for W in range(20, 120, 2):\n",
    "        for H in range(10, 40, 2):\n",
    "            bricks = brick_count(L, W, H)\n",
    "            if bricks <= MAX_BRICKS:\n",
    "                inner_vol = (L - 2 * t) * (W - 2 * t) * (H - 2 * t)\n",
    "                if best is None or inner_vol > best[0]:\n",
    "                    best = (inner_vol, L, W, H, bricks)\n",
    "\n",
    "inner_vol, L, W, H, total_bricks = best\n",
    "print(f\"Best solution: L={L}, W={W}, H={H} (grid units), Bricks={total_bricks}\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ad1c7f0e-127e-4644-9fd1-487026585374",
   "metadata": {},
   "outputs": [],
   "source": [
    "rows = []\n",
    "brick_id = 0\n",
    "door_x_min = 0\n",
    "door_x_max = 9  \n",
    "door_h_mm = 2100\n",
    "window_x_min = 0\n",
    "window_x_max = 12\n",
    "window_h_mm = 1200\n",
    "window_y_base = 1200  \n",
    "for z in range(H):  # height layers\n",
    "    for y in range(W):\n",
    "        for x in range(L):\n",
    "            # Skip interior hollow\n",
    "            if (t <= x < L - t) and (t <= y < W - t) and (t <= z < H - t):\n",
    "                continue\n",
    "\n",
    "            # Place brick only if starting position aligns with brick length (200mm = 2 grid)\n",
    "            if x % 2 == 0:\n",
    "                brick_id += 1\n",
    "                x_mm = x * UNIT\n",
    "                y_mm = y * UNIT\n",
    "                z_mm = z * UNIT\n",
    "                orientation = \"X\"  # along X-axis\n",
    "                active = 1\n",
    "\n",
    "                # Door removal on front wall (y = 0)\n",
    "                if y < t:\n",
    "                    if (x_mm >= 1000 and x_mm <= 1900) and (z_mm < door_h_mm):\n",
    "                        active = 0\n",
    "\n",
    "                # Window removal on right wall (x ≈ L-t)\n",
    "                if x >= L - t:\n",
    "                    if (z_mm >= window_y_base and z_mm < window_y_base + window_h_mm) and (y_mm >= 2500 and y_mm <= 3700):\n",
    "                        active = 0\n",
    "\n",
    "                rows.append([brick_id, x_mm, y_mm, z_mm, orientation, active])\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "51668f15-8496-4df4-bff6-c1b2ef419d03",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Wrote 9896 bricks to placement.csv\n"
     ]
    }
   ],
   "source": [
    "# Save to CSV\n",
    "with open(\"placement.csv\", \"w\", newline=\"\") as f:\n",
    "    writer = csv.writer(f)\n",
    "    writer.writerow([\"brick_id\", \"x_mm\", \"y_mm\", \"z_mm\", \"orientation\", \"active\"])\n",
    "    writer.writerows(rows)\n",
    "\n",
    "print(f\"Wrote {len(rows)} bricks to placement.csv\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "eb30eeb3-f3ad-4dc3-a69c-1b2d0df5b3a3",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "499ea788-d0b3-49e7-b405-c4f157a1ddc5",
   "metadata": {},
   "outputs": [
    {
     "ename": "ValueError",
     "evalue": "Missing required columns. Expected {'y_mm', 'z_mm', 'orientation', 'x_mm', 'hide'}",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mValueError\u001b[0m                                Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[13], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;66;03m# In a new Jupyter cell\u001b[39;00m\n\u001b[1;32m----> 2\u001b[0m render(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mplacement.csv\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "Cell \u001b[1;32mIn[11], line 12\u001b[0m, in \u001b[0;36mrender\u001b[1;34m(csv_file)\u001b[0m\n\u001b[0;32m     10\u001b[0m required \u001b[38;5;241m=\u001b[39m {\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mx_mm\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124my_mm\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mz_mm\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124morientation\u001b[39m\u001b[38;5;124m'\u001b[39m, \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mhide\u001b[39m\u001b[38;5;124m'\u001b[39m}\n\u001b[0;32m     11\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m required\u001b[38;5;241m.\u001b[39missubset(df\u001b[38;5;241m.\u001b[39mcolumns):\n\u001b[1;32m---> 12\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m \u001b[38;5;167;01mValueError\u001b[39;00m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mMissing required columns. Expected \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mrequired\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m     14\u001b[0m \u001b[38;5;66;03m# Keep only visible bricks\u001b[39;00m\n\u001b[0;32m     15\u001b[0m df \u001b[38;5;241m=\u001b[39m df[df[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mhide\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m!=\u001b[39m \u001b[38;5;241m0\u001b[39m]\u001b[38;5;241m.\u001b[39mcopy()\n",
      "\u001b[1;31mValueError\u001b[0m: Missing required columns. Expected {'y_mm', 'z_mm', 'orientation', 'x_mm', 'hide'}"
     ]
    }
   ],
   "source": [
    "# In a new Jupyter cell\n",
    "render(\"placement.csv\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "b0decced-7f75-4570-ad8a-f19a4d96837a",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Grid cells: X=45, Y=47, Z=39\n",
      "Saved top_view.png\n",
      "Saved side_view.png\n"
     ]
    }
   ],
   "source": [
    "#!/usr/bin/env python3\n",
    "\"\"\"\n",
    "render.py\n",
    "\n",
    "Usage:\n",
    "    python render.py [placement.csv]\n",
    "\n",
    "If no argument is given or the first arg is '-f' (Jupyter), the script uses 'placement.csv' by default.\n",
    "\n",
    "Output:\n",
    "    top_view.png   -> plan view (X vs Y). Shows the top-most visible brick color per footprint.\n",
    "    side_view.png  -> elevation (X vs Z). Draws bricks by z-level so stacking is visible.\n",
    "\n",
    "Expected CSV columns:\n",
    "    brick_id,x_mm,y_mm,z_mm,orientation,hide\n",
    "If 'hide' is missing, 'active' is used (active==0 treated as hidden).\n",
    "Coordinates are in mm; grid unit = 100 mm. Brick size = 200 x 100 x 100 mm -> spans 2x1x1 cells.\n",
    "\"\"\"\n",
    "import csv, sys, os\n",
    "from PIL import Image, ImageDraw, ImageFont\n",
    "\n",
    "UNIT = 100  # mm per grid cell\n",
    "CELL_PIXEL = 8  # pixels per grid cell when rendering (tweak to change image size)\n",
    "\n",
    "# Colors\n",
    "COLOR_X = (200, 60, 60)   # X oriented bricks (red)\n",
    "COLOR_Y = (60, 160, 80)   # Y oriented bricks (green)\n",
    "COLOR_Z = (60, 110, 200)  # Z oriented bricks (blue)\n",
    "COLOR_HIDDEN = (240, 240, 240)\n",
    "BG = (255, 255, 255)\n",
    "GRID_COLOR = (220, 220, 220)\n",
    "LEGEND_BG = (250, 250, 250)\n",
    "\n",
    "def safe_int(val, default=0):\n",
    "    try:\n",
    "        return int(float(val))\n",
    "    except:\n",
    "        return default\n",
    "\n",
    "def read_csv(path):\n",
    "    rows = []\n",
    "    with open(path, newline='') as f:\n",
    "        reader = csv.DictReader(f)\n",
    "        for r in reader:\n",
    "            rows.append(r)\n",
    "    return rows\n",
    "\n",
    "def normalize(rows):\n",
    "    \"\"\"Return list of bricks with integer cell coords and visibility flag.\"\"\"\n",
    "    bricks = []\n",
    "    for r in rows:\n",
    "        x_mm = safe_int(r.get('x_mm', 0))\n",
    "        y_mm = safe_int(r.get('y_mm', 0))\n",
    "        z_mm = safe_int(r.get('z_mm', 0))\n",
    "        x_cell = x_mm // UNIT\n",
    "        y_cell = y_mm // UNIT\n",
    "        z_cell = z_mm // UNIT\n",
    "        orient = (r.get('orientation') or r.get('orient') or '').strip().upper() or 'X'\n",
    "        # hide precedence: 'hide' if present else use inverse of active (active==0 -> hidden)\n",
    "        hide_val = r.get('hide', '').strip()\n",
    "        if hide_val != '':\n",
    "            hidden = (safe_int(hide_val) == 0)\n",
    "        else:\n",
    "            if 'active' in r and r['active'].strip() != '':\n",
    "                hidden = (safe_int(r.get('active', 1)) == 0)\n",
    "            else:\n",
    "                hidden = False\n",
    "        bricks.append({\n",
    "            'brick_id': r.get('brick_id',''),\n",
    "            'x_cell': x_cell,\n",
    "            'y_cell': y_cell,\n",
    "            'z_cell': z_cell,\n",
    "            'orientation': orient,\n",
    "            'visible': (not hidden)\n",
    "        })\n",
    "    return bricks\n",
    "\n",
    "def compute_grid(bricks):\n",
    "    max_x = 0; max_y = 0; max_z = 0\n",
    "    for b in bricks:\n",
    "        x = b['x_cell']; y = b['y_cell']; z = b['z_cell']\n",
    "        if b['orientation'] == 'X':\n",
    "            span_x = 2; span_y = 1\n",
    "        elif b['orientation'] == 'Y':\n",
    "            span_x = 1; span_y = 2\n",
    "        else:\n",
    "            span_x = 1; span_y = 1\n",
    "        max_x = max(max_x, x + span_x)\n",
    "        max_y = max(max_y, y + span_y)\n",
    "        max_z = max(max_z, z + 1)\n",
    "    # add small margin\n",
    "    return max_x + 1, max_y + 1, max_z + 1\n",
    "\n",
    "def color_for(orient):\n",
    "    if orient == 'X': return COLOR_X\n",
    "    if orient == 'Y': return COLOR_Y\n",
    "    return COLOR_Z\n",
    "\n",
    "def draw_top(bricks, grid_x, grid_y, out_path='top_view.png'):\n",
    "    # For each footprint cell (x,y) choose the visible brick with highest z\n",
    "    top_map = {}  # (x,y) -> (z, color)\n",
    "    for b in bricks:\n",
    "        if not b['visible']: continue\n",
    "        x = b['x_cell']; y = b['y_cell']; z = b['z_cell']\n",
    "        orient = b['orientation']\n",
    "        if orient == 'X':\n",
    "            cells = [(x,y),(x+1,y)]\n",
    "        elif orient == 'Y':\n",
    "            cells = [(x,y),(x,y+1)]\n",
    "        else:\n",
    "            cells = [(x,y)]\n",
    "        col = color_for(orient)\n",
    "        for (cx,cy) in cells:\n",
    "            key = (cx,cy)\n",
    "            prev = top_map.get(key)\n",
    "            if prev is None or z >= prev[0]:\n",
    "                top_map[key] = (z, col)\n",
    "\n",
    "    W = grid_x * CELL_PIXEL\n",
    "    H = grid_y * CELL_PIXEL\n",
    "    img = Image.new('RGB', (W+1, H+1), BG)\n",
    "    draw = ImageDraw.Draw(img)\n",
    "    # grid lines\n",
    "    for gx in range(0, W+1, CELL_PIXEL):\n",
    "        draw.line([(gx,0),(gx,H)], fill=GRID_COLOR)\n",
    "    for gy in range(0, H+1, CELL_PIXEL):\n",
    "        draw.line([(0,gy),(W,gy)], fill=GRID_COLOR)\n",
    "\n",
    "    # draw cells\n",
    "    for (cx,cy), (z,col) in top_map.items():\n",
    "        left = cx * CELL_PIXEL\n",
    "        top = cy * CELL_PIXEL\n",
    "        right = left + CELL_PIXEL - 1\n",
    "        bottom = top + CELL_PIXEL - 1\n",
    "        draw.rectangle([left, top, right, bottom], fill=col, outline=(0,0,0))\n",
    "\n",
    "    # legend\n",
    "    draw.rectangle([(5,5),(200,75)], fill=LEGEND_BG, outline=(0,0,0))\n",
    "    draw.rectangle([(12,12),(32,32)], fill=COLOR_X, outline=(0,0,0)); draw.text((36,12),\"X-orient\", fill=(0,0,0))\n",
    "    draw.rectangle([(12,34),(32,54)], fill=COLOR_Y, outline=(0,0,0)); draw.text((36,34),\"Y-orient\", fill=(0,0,0))\n",
    "    draw.rectangle([(12,56),(32,76)], fill=COLOR_Z, outline=(0,0,0)); draw.text((36,56),\"Z-orient\", fill=(0,0,0))\n",
    "\n",
    "    img.save(out_path)\n",
    "    print(\"Saved\", out_path)\n",
    "\n",
    "def draw_side(bricks, grid_x, grid_z, out_path='side_view.png'):\n",
    "    # Draw bricks by their X-span and Z-level; bricks at higher z overwrite lower ones when drawn later.\n",
    "    W = grid_x * CELL_PIXEL\n",
    "    H = grid_z * CELL_PIXEL\n",
    "    img = Image.new('RGB', (W+1, H+1), BG)\n",
    "    draw = ImageDraw.Draw(img)\n",
    "    # grid lines\n",
    "    for gx in range(0, W+1, CELL_PIXEL):\n",
    "        draw.line([(gx,0),(gx,H)], fill=GRID_COLOR)\n",
    "    for gy in range(0, H+1, CELL_PIXEL):\n",
    "        draw.line([(0,gy),(W,gy)], fill=GRID_COLOR)\n",
    "\n",
    "    # sort bricks by z ascending so higher bricks drawn later\n",
    "    sorted_bricks = sorted([b for b in bricks if b['visible']], key=lambda b: b['z_cell'])\n",
    "    for b in sorted_bricks:\n",
    "        x = b['x_cell']; z = b['z_cell']; orient = b['orientation']\n",
    "        if orient == 'X':\n",
    "            w_cells = 2\n",
    "        else:\n",
    "            # Y and Z both appear 1 cell wide in side view (Y runs into depth)\n",
    "            w_cells = 1\n",
    "        left = x * CELL_PIXEL\n",
    "        right = left + w_cells * CELL_PIXEL - 1\n",
    "        # top/bottom in pixel coords: Z=0 should be bottom\n",
    "        top = H - (z + 1) * CELL_PIXEL\n",
    "        bottom = H - z * CELL_PIXEL - 1\n",
    "        draw.rectangle([left, top, right, bottom], fill=color_for(orient), outline=(0,0,0))\n",
    "\n",
    "    # legend\n",
    "    draw.rectangle([(5,5),(200,75)], fill=LEGEND_BG, outline=(0,0,0))\n",
    "    draw.rectangle([(12,12),(32,32)], fill=COLOR_X, outline=(0,0,0)); draw.text((36,12),\"X-orient\", fill=(0,0,0))\n",
    "    draw.rectangle([(12,34),(32,54)], fill=COLOR_Y, outline=(0,0,0)); draw.text((36,34),\"Y-orient\", fill=(0,0,0))\n",
    "    draw.rectangle([(12,56),(32,76)], fill=COLOR_Z, outline=(0,0,0)); draw.text((36,56),\"Z-orient\", fill=(0,0,0))\n",
    "\n",
    "    img.save(out_path)\n",
    "    print(\"Saved\", out_path)\n",
    "\n",
    "def main():\n",
    "    # pick csv path: prefer user arg, but fallback to 'placement.csv' (also handle Jupyter '-f')\n",
    "    arg = None\n",
    "    if len(sys.argv) >= 2 and sys.argv[1] not in ('-f','--file'):\n",
    "        arg = sys.argv[1]\n",
    "    csv_path = arg or 'placement.csv'\n",
    "    if not os.path.exists(csv_path):\n",
    "        print(\"CSV not found:\", csv_path)\n",
    "        print(\"Usage: python render.py placement.csv\")\n",
    "        sys.exit(1)\n",
    "\n",
    "    rows = read_csv(csv_path)\n",
    "    if not rows:\n",
    "        print(\"No rows in CSV\")\n",
    "        sys.exit(1)\n",
    "    bricks = normalize(rows)\n",
    "    grid_x, grid_y, grid_z = compute_grid(bricks)\n",
    "    print(f\"Grid cells: X={grid_x}, Y={grid_y}, Z={grid_z}\")\n",
    "\n",
    "    draw_top(bricks, grid_x, grid_y, out_path='top_view.png')\n",
    "    draw_side(bricks, grid_x, grid_z, out_path='side_view.png')\n",
    "\n",
    "if __name__ == '__main__':\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "e3bbb90c-1b87-4799-be9b-b3e27dec5ccf",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 9530 visible bricks.\n",
      "✅ Saved iso_view.png\n",
      "✅ top_view.png, side_view.png, iso_view.png saved successfully.\n"
     ]
    }
   ],
   "source": [
    "#!/usr/bin/env python3\n",
    "\"\"\"\n",
    "render.py — Visualize hollow cuboid (top, side, and 3D views)\n",
    "Run:\n",
    "    python render.py placement.csv\n",
    "Outputs:\n",
    "    top_view.png\n",
    "    side_view.png\n",
    "    iso_view.png\n",
    "\"\"\"\n",
    "\n",
    "import sys, os, csv\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "from mpl_toolkits.mplot3d.art3d import Poly3DCollection\n",
    "\n",
    "def read_data(csv_path):\n",
    "    df = pd.read_csv(csv_path)\n",
    "    if 'hide' not in df.columns:\n",
    "        df['hide'] = df.get('active', 1)\n",
    "    df = df[df['hide'] != 0].copy()\n",
    "    return df\n",
    "\n",
    "def color_for(o):\n",
    "    o = str(o).upper()\n",
    "    if o == 'X': return '#e74c3c'  # red\n",
    "    if o == 'Y': return '#27ae60'  # green\n",
    "    if o == 'Z': return '#2980b9'  # blue\n",
    "    return '#95a5a6'               # gray fallback\n",
    "\n",
    "# ---------- 2D Views ----------\n",
    "def draw_top(df):\n",
    "    plt.figure(figsize=(6,6))\n",
    "    plt.scatter(df.x_mm, df.y_mm, c=df.orientation.map(color_for))\n",
    "    plt.title(\"Top View (X-Y)\")\n",
    "    plt.xlabel(\"X (mm)\"); plt.ylabel(\"Y (mm)\")\n",
    "    plt.axis('equal'); plt.grid(True, alpha=0.4)\n",
    "    plt.savefig(\"top_view.png\", dpi=300, bbox_inches='tight')\n",
    "    plt.close()\n",
    "\n",
    "def draw_side(df):\n",
    "    plt.figure(figsize=(6,4))\n",
    "    plt.scatter(df.x_mm, df.z_mm, c=df.orientation.map(color_for))\n",
    "    plt.title(\"Side View (X-Z)\")\n",
    "    plt.xlabel(\"X (mm)\"); plt.ylabel(\"Z (mm)\")\n",
    "    plt.axis('equal'); plt.grid(True, alpha=0.4)\n",
    "    plt.savefig(\"side_view.png\", dpi=300, bbox_inches='tight')\n",
    "    plt.close()\n",
    "\n",
    "# ---------- 3D Isometric View ----------\n",
    "def draw_iso(df):\n",
    "    fig = plt.figure(figsize=(7,6))\n",
    "    ax = fig.add_subplot(111, projection='3d')\n",
    "\n",
    "    # Brick dimensions (mm)\n",
    "    L, W, H = 200, 100, 100\n",
    "\n",
    "    for _, row in df.iterrows():\n",
    "        x, y, z = row.x_mm, row.y_mm, row.z_mm\n",
    "        o = str(row.orientation).upper()\n",
    "        if o == 'X':\n",
    "            dx, dy, dz = L, W, H\n",
    "        elif o == 'Y':\n",
    "            dx, dy, dz = W, L, H\n",
    "        else:\n",
    "            dx, dy, dz = W, W, L\n",
    "\n",
    "        color = color_for(o)\n",
    "\n",
    "        # 8 corner points of brick\n",
    "        X = [x, x+dx, x+dx, x, x, x+dx, x+dx, x]\n",
    "        Y = [y, y, y+dy, y+dy, y, y, y+dy, y+dy]\n",
    "        Z = [z, z, z, z, z+dz, z+dz, z+dz, z+dz]\n",
    "\n",
    "        verts = [\n",
    "            [(X[0],Y[0],Z[0]),(X[1],Y[1],Z[1]),(X[2],Y[2],Z[2]),(X[3],Y[3],Z[3])],\n",
    "            [(X[4],Y[4],Z[4]),(X[5],Y[5],Z[5]),(X[6],Y[6],Z[6]),(X[7],Y[7],Z[7])],\n",
    "            [(X[0],Y[0],Z[0]),(X[1],Y[1],Z[1]),(X[5],Y[5],Z[5]),(X[4],Y[4],Z[4])],\n",
    "            [(X[2],Y[2],Z[2]),(X[3],Y[3],Z[3]),(X[7],Y[7],Z[7]),(X[6],Y[6],Z[6])],\n",
    "            [(X[1],Y[1],Z[1]),(X[2],Y[2],Z[2]),(X[6],Y[6],Z[6]),(X[5],Y[5],Z[5])],\n",
    "            [(X[4],Y[4],Z[4]),(X[7],Y[7],Z[7]),(X[3],Y[3],Z[3]),(X[0],Y[0],Z[0])]\n",
    "        ]\n",
    "\n",
    "        ax.add_collection3d(Poly3DCollection(verts, facecolors=color, linewidths=0.2, edgecolors='k', alpha=0.9))\n",
    "\n",
    "    ax.set_xlabel(\"X (mm)\")\n",
    "    ax.set_ylabel(\"Y (mm)\")\n",
    "    ax.set_zlabel(\"Z (mm)\")\n",
    "    ax.view_init(25, 35)\n",
    "    ax.set_box_aspect([1,1,0.6])\n",
    "    plt.title(\"3D View (Isometric)\")\n",
    "    plt.savefig(\"iso_view.png\", dpi=300, bbox_inches='tight')\n",
    "    plt.close()\n",
    "    print(\"✅ Saved iso_view.png\")\n",
    "\n",
    "# ---------- Main ----------\n",
    "def main():\n",
    "    csv_file = sys.argv[1] if len(sys.argv) > 1 and sys.argv[1] != \"-f\" else \"placement.csv\"\n",
    "    if not os.path.exists(csv_file):\n",
    "        print(f\"CSV not found: {csv_file}\")\n",
    "        return\n",
    "    df = read_data(csv_file)\n",
    "    print(f\"Loaded {len(df)} visible bricks.\")\n",
    "    draw_top(df)\n",
    "    draw_side(df)\n",
    "    draw_iso(df)\n",
    "    print(\"✅ top_view.png, side_view.png, iso_view.png saved successfully.\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c3780a19-51ce-49f6-be7a-b8e9b3c9ce69",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
